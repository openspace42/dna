#!/usr/bin/env bash

dna-backup_update_storage_info() {

	### fetch system / existing locally stored data.

	free_disk_space="$(df -m --output=avail "$backup_local_storage_path" | xargs | sed -e 's/Avail //g')"

	local_archive_items="$(ls -1q $backup_local_storage_path/archive | wc -l)"
	local_archive_size="$(du -sm $backup_local_storage_path/archive | xargs | sed "s|${backup_local_storage_path}/archive||g" | xargs)"

	### calculate upcoming backup size estimate.

	synthia-calculate_backup_size

}

dna-backup_purge_loop() {

	if [ "${local_archive_items}" -gt "${min_local_backups}" ]
	then

		counter=$(("${counter}" - 1))

		### prevent infinite loops in case of rm failure.

		if [ $counter = -1 ]
		then
			echo "${r-}${b-}Infinite loop error caught. Exiting...${b-}"
			exit 1
		fi

		if [ $local_archive_items -gt $counter ]
		then
			tail_number=$(( $counter + 1 ))
			( cd "$backup_local_storage_path/archive" && ls -t | tail -n +"$tail_number" | xargs -d '\n' rm )
		fi

		dna-backup_update_storage_info

	else

		if [ $counter = 0 ]
		then

			dna-echo -e "Even though there are no backups currently archived in local storage, meeting your setting of minimum backups to keep at | 0 |, there still isn't enough storage on the local storage's [$backup_local_storage_path] underlying volume."
			echo
			echo "${b-}Please inspect your disk for any files you don't need, or consider using an[other] external location by re-running the installer and choosing | custom | for the | backup_local_storage_location | setting.${x-}"
			echo

		else

			echo "${r-}${b-}The specified number of minimum backups to keep [$min_local_backups] is too high $error_description.${x-}"
			echo
			echo "${b-}Lower this figure by re-running the install and lowering this figure during configuration or make more space available on this machine.${x-}"
			echo

		fi

		if [ -d "$backup_local_storage_path/archive/old" ]
		then

			old_dir_size="$(du -sm "$backup_local_storage_path/archive/old" | xargs | sed -e "s|"${backup_local_storage_path}/archive/old"||g" | xargs)"

			echo "${b-}Found | $backup_local_storage_path/archive/old | directory weighing | $old_dir_size |.${x-}"
			echo
			echo "${b-}Consider freeing up space by removing these old backups if unneeded.${x-}"
			echo

		fi

		dna-exit

	fi

}

dna-backup_purge_backups() {

	## purge backups older than the latest $max_local_backups.

	local_archive_items="$(ls -1q ${backup_local_storage_path}/archive | wc -l)"

	if [ "${local_archive_items}" -gt "${max_local_backups}" ]
	then

		tail_number=$(( "${max_local_backups}" + 1 ))

		( cd "${backup_local_storage_path}/archive" && ls -t | tail -n +"${tail_number}" | xargs -d '\n' rm )

		dna-backup_update_storage_info

	fi

	dna-echo -m "You have: | ${o-}${local_archive_items}${n-} | local backups occupying: | ${y-}${local_archive_size} MB${n-} | of space."

	if [ "${local_archive_size}" -gt "${max_local_storage}" ]
	then

		dna-echo -e "Local archive size: [ ${n-}${local_archive_size} MB${r-} ] larger than: | ${n-}max_local_storage${r-} | setting [ ${n-}${max_local_storage} MB${r-} ]."

		dna-echo_operation -h "purging old backups while respecting your specified number of minimum backups to keep"

		error_description="to stay below the: | ${n-}max_local_storage${r-} | setting you chose"

		counter="${max_local_backups}"

		while [ "${local_archive_size}" -gt "${max_local_storage}" ]
		do

			dna-backup_purge_loop

		done

		dna-echo -s "Local archive size now low enough: [ ${n-}${local_archive_size} MB${g-} ] to respect your settings."
		dna-echo -m "Purged all backups older than the most recent: | ${y-}${counter}${n-} |."
		dna-echo -m "Continuing..."

	fi

	if [ "${backup_total_size_estimate}" -gt "${free_disk_space}" ]
	then

		dna-echo -e "Estimated backup size: [ ${n-}${backup_total_size_estimate} MB${r-} ] larger than available disk space: [ ${n-}${free_disk_space} MB${r-} ]."
		dna-echo -m "Now purging old backups while respecting your specified number of minimum backups to keep..."

		error_description="to free enough disk space for the next backup"

		counter="${max_local_backups}"

		while [ "${backup_total_size_estimate}" -gt "${free_disk_space}" ]
		do

			dna-backup_purge_loop

		done

		dna-echo -s "Enough free space: [ ${n-}${free_disk_space} MB${r-} ] now available for new backup."
		dna-echo -m "Purged all backups older than the most recent: | ${y-}${counter}${n-} |."
		dna-echo -m "Continuing..."

	fi

}

dna-backup_purge_dirs() {

	### purge temp and create directories.

	if [ -d "${backup_local_storage_path}/tmp" ]
	then
		rm -r "${backup_local_storage_path:?}/tmp"
	fi

	if [ -d "${backup_local_storage_path}/latest" ]
	then
		rm -r "${backup_local_storage_path:?}/latest"
	fi

	if [ -d "$backup_local_storage_path/restores" ]
	then
		rm -r "${backup_local_storage_path:?}/restores"
	fi

}

dna-backup_create_dirs() {

	if [ "${1:-null}" = "backup" ]
	then

		backup_name="${script_name}-${now}"

		backup_archive_dir="${backup_local_storage_path}/archive"
		backup_latest_dir="${backup_local_storage_path}/latest"
		backup_tmp_dir="${backup_local_storage_path}/tmp"

		backup_tmp_name_dir="${backup_local_storage_path}/tmp/${backup_name}"
		backup_tmp_name_conf_dir="${backup_tmp_name_dir}/conf"
		backup_tmp_name_data_dir="${backup_tmp_name_dir}/data"

		mkdir -p "${backup_archive_dir}"
		mkdir -p "${backup_latest_dir}"
		mkdir -p "${backup_tmp_dir}"

		mkdir -p "${backup_tmp_name_data_dir}"

	fi

	mkdir -p "${backup_tmp_name_dir}"

}

dna-backup_purge_incomplete_archives() {

	if [ -d "${backup_local_storage_path}/archive" ]
	then
		find "$backup_local_storage_path/archive" -type f -name '*.incomplete' -delete
	fi

}

dna-check_set_lockfile() {

	### Check for lockfile to avoid multiple simultaneous backups

	if [ -f "/tmp/${project_name}-backup-running-lockfile" ]
	then

	    dna-echo -e "It appears a ${project_name} backup is already running, perhaps an automated daily one, or perhaps the last one was interrupted."
	    dna-echo -m "If this *is* an automated daily one, please check that you're not running a manual one or that the last run was interrupted."
	    dna-echo -m "Running multiple simultaneous backups is absolutely not supported and will make both fail."

		if [ "${interactive}" = "y" ]
	    then
	        dna-ask_for_boolean -d "n" -q "If you're certain that another backup is NOT running, would you like to ignore the lockfile and continue?"
	        if [ "${boolean_output}" = "y" ]
	        then
	            dna-echo -m "Ok, continuing anyway..."
	            export lockfile_set="/tmp/${project_name}-backup-running-lockfile"
	        else
	            dna-echo -m "Ok, aborting..."
	            dna-exit
	        fi

	    else

	        dna-echo -m "If you're certain that another backup is NOT running, run this script manually and select to ignore the lockfile and continue when prompted."
	        dna-echo -m "Alternatively, you can also log into this machine and | ${o-}rm /tmp/${project_name}-backup-running-lockfile${n-} |."
	        dna-echo -e "Aborting backup for now."
	        dna-exit

	    fi

	else

	    ### Set lockfile.

	    export lockfile_set="/tmp/${project_name}-backup-running-lockfile"
	    touch "${lockfile_set}"

	fi

}

dna-calculate_backup_paths_size() {

	### fetch sizes for the directories that have the most impactful sizes that
	### will affect backups [such as '/var/www/' for nginx-related projects].
	### all sizes in MB.

	backup_paths_size_estimate=0

	for this_backup_path in "${!backup_paths_default_array[@]}"
	do

		if [ ${backup_paths_default_array[$this_backup_path]} = "existing" ]
		then

			### this is an existing backup path, calculate its size and add it
			### to the total.

			this_backup_path_size="$(du -sm ${this_backup_path} | cut -f1)"
			backup_paths_size_estimate="$((${backup_paths_size_estimate} + ${this_backup_path_size}))"

		else

			### this is a generated backup path, synthia will take care of
			### calculating its size afterwards.

			true

		fi

	done

}

dna-generate_additional_paths_dir() {

	for this_backup_path in "${!backup_paths_default_array[@]}"
	do

		if [ ${backup_paths_default_array[$this_backup_path]} = "generated" ]
		then

			mkdir -p "${tmp_project_backup_dir}/${this_backup_path}"

		fi

	done

}

dna-backup_locally_conf_dir() {

	rsync -aAXxL "${conf_dir}/" "${backup_tmp_name_conf_dir}"

}

dna-backup_locally_data_backup_paths() {

	for this_backup_path in "${!backup_paths_default_array[@]}"
	do

		# this_backup_path_name="$(echo ${this_backup_path} | sed "s|/|_|g" | sed "s|^_||g" | sed "s|-$||g")"

		if [ ${backup_paths_default_array[$this_backup_path]} = "existing" ]
		then

			rsync -aAXxRL "${this_backup_path}/" "${backup_tmp_name_data_dir}/"

		else

			mkdir -p "${backup_tmp_name_data_dir}/other/"
			rsync -aAXxL "${tmp_project_dir}/${this_backup_path}/" "${backup_tmp_name_data_dir}/other/${this_backup_path}/"

		fi

	done

}

dna-archive_local_backup() {

	dna-echo_operation -h "archiving backup and storing it in: | ${l-}${backup_archive_dir}${n-} |."

	cd "${backup_tmp_dir}"

    if [ -z "${backup_last_before_restore-}" ]
	then

    	## tar [and - if chosen - bzip2] this backup archive.

		if [ "$backup_compression_type" = "bz2" ]
		then

			output_file_name="${backup_name}.tar.bz2"
			output_file_path="${backup_local_storage_path}/archive/${output_file_name}"

	    	tar cSf - ${backup_name} -P | pv -s $(du -sb ${backup_name} | awk '{print $1}') | bzip2 > "${output_file_path}.incomplete"

		else

			output_file_name="${backup_name}.tar"
			output_file_path="${backup_local_storage_path}/archive/${output_file_name}"

			tar cSf - ${backup_name} -P | pv -s $(du -sb ${backup_name} | awk '{print $1}') > "${output_file_path}.incomplete"

		fi

    else

        ## tar [and - if chosen - bzip2] this backup archive.
		## give local backup a custom name so that it's clear it's the last one
		## before a restore.

		if [ "${backup_compression_type}" = "bz2" ]
		then

			output_file_name="${backup_name}-last-backup-before-${now}-restore.tar.bz2"
			output_file_path="${backup_local_storage_path}/archive/${output_file_name}"

	    	tar cSf - ${backup_name} -P | pv -s $(du -sb ${backup_name} | awk '{print $1}') | bzip2 > "${output_file_path}.incomplete"

		else

			output_file_name="${backup_name}-last-backup-before-${now}-restore.tar"
			output_file_path="${backup_local_storage_path}/archive/${output_file_name}"

			tar cSf - ${backup_name} -P | pv -s $(du -sb ${backup_name} | awk '{print $1}')> "${output_file_path}.incomplete"

		fi

    fi

	cd -

	echo

	mv "${output_file_path}.incomplete" "${output_file_path}"

	dna-echo_operation -t

}

dna-check_install_complete() {

	if [ -z ${skip_install_complete_check-} ]
	then

		### abort if the current installation was never completed.

		dna-check_install_complete

		if [ "${install_complete}" = "n" ]
		then

			dna-echo -e "It appears ${project_name} is not currently installed or there is an incomplete installation on this machine."
	        dna-echo -m "This backup script only works on a fully installed ${project_name} instance."
	        dna-echo -m "Please finish installing ${project_name} before running this script."
			dna-exit

		fi

	fi

}

dna-backup_locally() {

	if [ -z "${backup_skip_install_complete_check-}" ]
	then

		dna-check_install_complete

	fi

	dna-backup_locally_conf_dir

    synthia-backup_locally

    dna-archive_local_backup

	if [ -n "${backup_last_before_restore-}" ]
	then

		### if not restoring a previous state of this same installation, then
		### move the backups directory to an "old" named one.

		if [ "${restore_source}" = "here" ]
		then

			dna-echo -m "Last backup before restore archived to directory: | ${l-}${backup_local_storage_path}/archive${n-} |."

		else

			mkdir -p "${backup_local_storage_path}/old"

			mv "${backup_local_storage_path}/archive" "${backup_local_storage_path}/old/archive-old-before-restore-on-${now}"

			if [ -d "${duplicity_log_dir}/backup" ]
			then
				mkdir -p "${duplicity_log_dir}/old"
				mv "${duplicity_log_dir}/backup/" "${duplicity_log_dir}/old/backup-old-before-restore-on-${now}"
			fi

			dna-echo -m "Last backup before restore archived to directory: | ${l-}${backup_local_storage_path}/old/archive-old-before-restore-on-${now}${n-} |."

		fi

	fi

}

dna-backup() {

	### initiate.

	dna-backup_purge_dirs

	dna-backup_create_dirs backup

	if [ "${backup_locally_mode_default}" = "enabled" ]
	then

		dna-backup_purge_incomplete_archives

		dna-backup_update_storage_info

		dna-backup_purge_backups

	fi

	### initiate s3 and test restore.

	if [ "$backup_archival_location" = "s3" ] && [ -z "${backup_locally_only-}" ]
	then

		if [ "${backup_test_restore_mode_default}" = "enabled" ]
		then

		    dna-restore_from_S3 test

		fi

	    dna-backup_purge_dirs

	    dna-backup_create_dirs backup

	fi

	### perform pre-backup operations.

	synthia-backup_pre_operations

	### backup locally.

	if [ "${backup_locally_mode_default}" = "enabled" ] && [ -z "${backup_s3_only-}" ]
	then

		dna-backup_locally

		### perform post-backup operations.

		synthia-backup_post_operations

	fi

	### backup to s3.

	if [ "${backup_archival_location}" = "s3" ]
	then

	    if [ "${s3_restore_test_failed-null}" = "y" ]
	    then

	        dna-echo -e "Skipping S3 backup because of a previous test restore failure."

	        rm -r "${backup_tmp_dir}"

	    else

			if [ "${backup_locally_mode_default}" = "enabled" ]
			then

		    	mv "${backup_tmp_dir}"/* "${backup_latest_dir}"

			fi

	    	############################################################################

	    	dna-backup_to_s3

			if [ "${backup_locally_mode_default}" = "disabled" ]
			then

				### perform post-backup operations.

				synthia-backup_post_operations

			fi

	    fi

	else

		if [ "${backup_locally_mode_default}" = "disabled" ]
		then

			dna-echo -e "Local backups disabled and S3 backups not enabled. Not performing any backups."

			### perform post-backup operations.

			synthia-backup_post_operations

		fi

		rm -r "$backup_tmp_dir"

	fi

}

dna-backup_cleanup() {

	if [ -d "$backup_local_storage_path/tmp" ]
	then
		rm -r "${backup_local_storage_path:?}/tmp"
	fi

	dna-backup_purge_dirs

	if [ -f "/tmp/${project_name}-backup-running-lockfile" ]
	then
	    rm "/tmp/${project_name}-backup-running-lockfile"
	fi

	if [ "${s3_restore_test_failed-null}" = "y" ]
	then
	    dna-exit
	fi

	dna-echo -s "Backup complete!"

}

dna-last_local_backup() {

    dna-echo "Now performing a last backup [locally - no S3 of course] this machine's currently running $project_name installation just in case..."

}

dna-restore_from_here() {

	if [ ! -d "$backup_local_storage_path/archive" ]
	then
		echo "${r-}${b-}Local backups directory [$backup_local_storage_path/archive] not found.${x-}"
		echo
		echo "${b-}It's possible you've already partially run this restore script choosing the | elsewhere | option, or that this machine never successfully ran a backup.${x-}"
		echo
		echo "${b-}Check your $install_dir for a directory called | backups(-[something]) | and if you find something rename the most recently datestamped directory to | backups | ."
		echo
		echo "${b-}Exiting...${x-}"
		echo
		exit 1
	fi

	count="$(ls -1 $backup_local_storage_path/archive/*.tar* 2>/dev/null | wc -l)"
	if [ $count = 0 ]
	then
		echo "${r-}${b-}No backup archives found in local backups directory [$backup_local_storage_path/archive].${x-}"
		echo
		echo "${b-}It's possible you've already partially run this restore script choosing the | elsewhere | option, or that this machine never successfully ran a backup.${x-}"
		echo
		echo "${b-}Check your $install_dir for a directory called | backups(-[something]) | and if you find something rename the most recently datestamped directory to | backups | ."
		echo
		echo "${b-}Exiting...${x-}"
		echo
		exit 1
	fi

	echo "${b-}These are the backup dates available for restore:${x-}"
	echo
	ls -1 "$backup_local_storage_path/archive" | sed -e "s/${project_name}-backup-//g" | sed -e 's/.tar//g' | sed -e 's/.bz2//g'
	echo
	read -rp "${b-}[press enter to continue...]${x-}"
	clear

	choice="${b-}Now choose the file you'd like to restore: ${x-}"
	echo "$choice"
	echo

	set +u

	cd "$backup_local_storage_path/archive"
	unset options i
	while IFS= read -r -d $'\n' f; do
		options[i++]="$f"
	done < <(find ./ -maxdepth 1 -type f -name "*.tar*" | sort -r )
	IFS=$' \t\n'

	set -u

	accept=n
	until [ $accept = "y" ]
	do

		select sel_backup_file in "${options[@]}" "exit"
		do
			echo
			case $sel_backup_file in
				*.tar)
				echo "${b-}Backup file $sel_backup_file selected.${x-}"
				break
				;;
				"exit")
				echo "${b-}Exiting...${x-}"
				echo
				exit
				;;
				*)
				echo "${r-}${b-}Invalid option. Retry...${x-}"
				echo
				;;
			esac
		done
		echo

		valid=n
		until [ $valid = "y" ]
		do
			read -n 1 -rp "${b-}Is this the correct file?${x-} (${b-}Y${x-}[es]/${b-}n${x-}[o]/${b-}e${x-}[xit]) " answer;
			case $answer in
				"")
				echo
				valid=y
				accept=y
				;;
				y)
				echo -e "\\n"
				valid=y
				accept=y
				;;
				n)
				echo -e "\\n"
				echo "${b-}No problem, please select your desired file again now...${x-}"
				echo
				valid=y
				accept=n
				;;
				e)
				echo -e "\\n"
				echo "${b-}Exiting...${x-}"
				echo
				exit
				;;
				*)
				echo -e "\\n"
				echo "${b-}Invalid option. Retry...${x-}"
				echo
				valid=n
				accept=n
				;;
			esac
		done

	done

	mkdir -p "$backup_local_storage_path/restores/local/"

	if [ ${sel_backup_file: -4} == ".bz2" ]
	then
		tar -xvjf "$sel_backup_file" -C "$backup_local_storage_path/restores/local/"
	else
		tar -xvf "$sel_backup_file" -C "$backup_local_storage_path/restores/local/"
	fi

	echo

}

dna-restore_from_standalone() {

	echo "${b-}Ok, restoring from a standalone $project_name backup file.${x-}"
	echo
	mkdir -p "/root/$project_name-restore/"
	read -p "${b-}Do you have a file called | $project_name-backup-[date].tar[.bz2] | [or similar]? (Y/n): ${x-}" -n 1 -r
	echo
	if [[ ! $REPLY =~ ^[Nn]$ ]]
	then
		defined=n
		until [ $defined = "y" ]
		do
			exists=n
			until [ $exists = "y" ]
			do
				standalone_backup_file=""
				until [ ! $standalone_backup_file = "" ]
				do
					read -rp "${b-}Ok, specify the path to that file now: ${x-}" standalone_backup_file
					echo
				done
				if [ -f "$standalone_backup_file" ]
				then
					exists=y
				else
					echo "${r-}${b-}The specified file does not exists. Please retry...${x-}"
					echo
					exists=n
				fi
			done
			valid=n
			until [ $valid = "y" ]
			do
				read -n 1 -rp "${b-}Is | $standalone_backup_file | correct? (Y/n/e[xit]) ${x-}" answer;
				case $answer in
					"")
					echo
					valid=y
					defined=y
					;;
					y)
					echo -e "\\n"
					valid=y
					defined=y
					;;
					n)
					echo -e "\\n"
					echo "${b-}Ok, then please try again...${x-}"
					echo
					valid=y
					defined=n
					;;
					e)
					echo -e "\\n"
					echo "${b-}Exiting...${x-}"
					echo
					exit
					;;
					*)
					echo -e "\\n"
					echo "${r-}${b-}Invalid option. Retry...${x-}"
					echo
					valid=n
					defined=n
					;;
				esac
			done
		done
		echo "${b-}Backup file $standalone_backup_file selected.${x-}"
		echo
		if [ ${standalone_backup_file: -4} == ".bz2" ]
		then
			tar -xvjf "$standalone_backup_file" -C "/root/$project_name-restore/"
		else
			tar -xvf "$standalone_backup_file" -C "/root/$project_name-restore/"
		fi
		subdir=("/root/$project_name-restore/"*/)
		restoresubdir="$(echo "$subdir" | sed "s|/root/${project_name}-restore/||" | tr -d '/')"
		mv "/root/$project_name-restore/$restoresubdir"/* "/root/$project_name-restore/"
		rm -r "/root/$project_name-restore/$restoresubdir"
	else
		echo
		echo "${b-}Ok, no problem. Make sure you populate the | /root/$project_name-restore/ | directory with the following files/directories from your standalone backup:${x-}"
		echo
		restore_from_standalone_content_description
		echo
		echo "${r-}${b-}If you don't correctly place all the above files/directories, the restore will not work correctly [you will be alerted if something is wrong further along this script]${x-}"
		echo
		echo "${b-}As soon as you're done moving these items into place...${x-}"
		echo
		read -rp "${b-}[press enter to continue...]${x-}"
		clear
		if [ $validate_standalone_restore_content = "y" ]
		then
			restore_from_standalone_content_validation
		fi
	fi

}

dna-backup_generate_duplicity_includes() {

	> "${tmp_project_dir}/duplicity-include"

	for this_backup_path in "${!backup_paths_default_array[@]}"
	do

		echo "${this_backup_path}" >> "${tmp_project_dir}/duplicity-include"

	done

}

dna-duplicity_source_vars() {

	### export some ENV variables so you don't have to type anything.

	dna-get_hostname

	export HOST="$(hostname)"
	export DATE="$(date +%Y-%m-%d)"
	export MAILADDR="${admin_mail-}"
	export TODAY="$(date +%d%m%Y)"

	export AWS_ACCESS_KEY_ID="${s3_access_key_id}"
	export AWS_SECRET_ACCESS_KEY="${s3_secret_access_key}"
	export PASSPHRASE="${backups_passphrase}"

}

dna-duplicity_unset_vars() {

	### reset the env variables. don't need them sitting around.

	unset HOST DATE MAILADDR TODAY AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY PASSPHRASE

}

dna-duplicity_loop() {

	### raise ulimit for open files.

	if ! grep -q "fs.file-max = 2097152" "/etc/sysctl.conf"
	then
		echo "fs.file-max = 2097152" >> "/etc/sysctl.conf"
	fi

	standard_ulimit_n="$(ulimit -n)"
	ulimit -n "524288"

	### your GPG key.

	# GPG_KEY= # Insert GPG key here if using GPG

	### the S3 destination followed by bucket name.

	DEST="s3://$s3_endpoint/$s3_bucket_name/$project_name/latest/"

	dna-duplicity_source_vars

	if [ "${1:-null}" = "backup" ]
	then
		duplicity_mode="backup"
	else
		duplicity_mode="restore"
	fi

	duplicity_base_dir="${logs_dir}/${project_name}-duplicity"
	duplicity_log_dir="${duplicity_base_dir}/${duplicity_mode}"

	### set up some variables for logging.

	LOGFILE="${duplicity_log_dir}/${duplicity_mode}.log"
	DAILYLOGFILE="${duplicity_log_dir}/${duplicity_mode}.daily.log"
	FULLBACKLOGFILE="${duplicity_log_dir}/${duplicity_mode}.full.log"

	is_running=$(ps -ef | grep duplicity  | grep python | wc -l)

	if [ ! -d "${duplicity_log_dir}" ]
	then
		mkdir -p "${duplicity_log_dir}"
	fi

	if [ ! -f "${FULLBACKLOGFILE}" ]
	then
		touch "${FULLBACKLOGFILE}"
	fi

	if [ "${is_running}" -eq 0 ]
	then

		### clear the old daily log file.

		cat /dev/null > ${DAILYLOGFILE}

		### trace function for logging, don't change this.

		trace() {
			stamp=$(date +%Y-%m-%d_%H:%M:%S)
			echo "$stamp: $*" >> ${DAILYLOGFILE}
		}

		if [ "${1:-null}" = "backup" ]
		then

			### set the source for the backup.
			### use / for full system backup [not the case here].

			if [ "${backup_locally_mode_default}" = "enabled" ]
			then

				SOURCE="--include ${backup_local_storage_path}/latest/"

			else

				synthia-backup_additional_backup_paths

				dna-backup_generate_duplicity_includes

				SOURCE="--include-filelist ${tmp_project_dir}/duplicity-include"

			fi

		fi

		FULL=
		tail -1 "${FULLBACKLOGFILE}" | grep "${TODAY}" > /dev/null || true
		if [ $? -ne 0 -a "$(date +%d)" -eq 1 ]
		then
			FULL=full
		fi;

		trace "Backup for local filesystem started"

		set +e

		if [ "${1:-null}" = "backup" ]
		then

			### how long to keep backups for.

			OLDER_THAN="$duplicity_min_history"

			trace "... removing old backups"

			duplicity remove-older-than "${OLDER_THAN}" "${DEST}" >> "${DAILYLOGFILE}" 2>&1  || true

		fi

		trace "... backing up filesystem"

		#    duplicity \
		#        ${FULL} \
		#        --encrypt-key=${GPG_KEY} \
		#        --sign-key=${GPG_KEY} \
		#        --include=/var/rsnap-mysql \
		#        --include=/var/www \
		#        --include=/etc \
		#        --exclude=/** \
		#        ${SOURCE} ${DEST} >> ${DAILYLOGFILE} 2>&1

		if [ "${1:-null}" = "backup" ]
		then

			### insert '--encrypt-key' and '--sign-key' after '${full}' if using
			### gpg.

			duplicity --progress --allow-source-mismatch ${FULL} / ${SOURCE} --exclude '**' "${DEST}"

		elif [ "${1:-null}" = "restore" ]
		then

			duplicity "${DEST}" "$backup_local_storage_path/restores/s3/" 2>&1 | tee "$backup_local_storage_path/tmp/duplicity-log"

		fi

		set -e

		trace "Backup for local filesystem complete"
		trace "------------------------------------"

		if [ "${1:-null}" = "backup" ]
		then

			### send the daily log file by email.

			BACKUPSTATUS=$(cat "$DAILYLOGFILE" | grep -i error | wc -l)

			if [ "${BACKUPSTATUS}" != "0" ]
			then

				cat "$DAILYLOGFILE" | mail -aFrom:"$script_name@$HOST" -s "ERROR in $script_name backup for $HOST on $DATE" $MAILADDR

			elif [ "${FULL}" = "full" ]
			then

				echo "$(date +%d%m%Y_%T) Full Back Done" >> "${FULLBACKLOGFILE}"

			fi

		fi

		### append the daily log file to the main log file.

		cat "${DAILYLOGFILE}" >> "${LOGFILE}"

		dna-duplicity_unset_vars

	else

		dna-echo -e "It appears duplicity is already running on this server."
		dna-echo -m "If you've manually overridden a lockfile check at the beginning of this script's execution, you should consider that it's likely another backup is occurring."
		dna-echo -m "If you're sure this is not the case, reboot the server and run this script again or see what happens at the next automated run."
		dna-exit

	fi

	### reset ulimit for open files.

	ulimit -Sn "${standard_ulimit_n}"

}

dna-backup_to_s3() {

	dna-echo_operation -h "backing up to S3"

    if [ -f "${conf_backups_s3_dir}/block_s3_backups" ]
    then
        dna-echo -e "Not performing backup as: | ${n-}${conf_backups_s3_dir}/block_s3_backups${r-} | file found."
        dna-echo -m "This should indicate that during installation you specified your intent to use this machine as a restore for a previous instance of ${project_name} backed up on S3."
        dna-echo -m "Ff this is the case, simply run the restore script right away. If it is not, and you want to use this machine for a new installation and OVERWRITE all backups currently on S3, erase this file."
        dna-echo -e "No backups will run on this instance until you perform the restore script or remove the file to specify your intent to use this machine as it is for a new installation."
		dna-exit
    fi

	dna-duplicity_loop backup

	### also upload today's full backup file to S3 if s3_monthly_uploads=y
	### [only if this is NOT a manual run].

	today_day_of_month="$(date +%-d)"

	if [ ${today_day_of_month} = "1" ] && [ ${interactive} = "n" ] && [ "${backup_locally_mode_default}" = "enabled" ]
	then

		dna-echo -m "Also performing duplicity-independent first-of-the-month upload of: | ${l-}"${output_file_name}"${n-} | to S3 as well."

		encrypt() {
			echo "$backups_passphrase" | gpg --output  "$backup_local_storage_path/tmp/$@.gpg" --passphrase-fd 0 --batch --yes --symmetric -z 9 --require-secmem --cipher-algo AES256 --s2k-cipher-algo AES256 --s2k-digest-algo SHA512 --s2k-mode 3 --s2k-count 65000000 --compress-algo BZIP2 $@
		}

		decrypt() {
			gpg $@
		}

		putS3() {
			path=$1
			file=$2
			aws_path=$3
			bucket="$s3_bucket_name"
			date=$(date +"%a, %d %b %Y %T %z")
			acl="x-amz-acl:public-read"
			content_type='application/x-compressed-tar'
			string="PUT\n\n$content_type\n$date\n$acl\n/$bucket$aws_path$file"
			signature=$(echo -en "${string}" | openssl sha1 -hmac "${s3_secret_access_key}" -binary | base64)
			curl -X PUT -T "$path/$file" \
			-H "Host: $bucket.$s3_endpoint" \
			-H "Date: $date" \
			-H "Content-Type: $content_type" \
			-H "$acl" \
			-H "Authorization: AWS ${s3_access_key_id}:$signature" \
			"https://${bucket}.${s3_endpoint}${aws_path}${file}"
		}

		( cd "${backup_local_storage_path}/archive/" && encrypt "${output_file_name}" )

		putS3 "${backup_local_storage_path}/tmp/" "${output_file_name}.gpg" "/${project_name}/archive/" 2> /dev/null

	fi

}



dna-restore_from_S3() {

	if [ "${1:-null}" = "test" ]
	then

		dna-echo -m "Testing restore from S3 to ${backup_local_storage_path}/restores/s3/ to ensure existing backups integrity and passphrase match."

	else

		dna-echo -m "Restoring from S3 to ${backup_local_storage_path}/restores/s3/."

	fi

	dna-echo -m "This is going to take some time and will NOT output any progress information until it's done."

	dna-duplicity_loop restore

	if grep -q "No backup chains found" "${backup_local_storage_path}/tmp/duplicity-log"
	then

		if [ "${1:-null}" = "test" ]
		then

			### this is the first backup, all is good.

			dna-echo -m "First S3 backup detected. Skipping restore test."

		else

			### no backups found on server, something's wrong.

			dna-echo -e "Restore from S3 failed."
			dna-echo -m "It appears there are no backups on the S3 server under the path: | ${y-}${project_name}/latest${n-} | [check the above output for messages like: | ${r-}No backup chains found${n-} |]."
			dna-exit

		fi

	else

		if grep -q "gpg: decryption failed: bad key" "${backup_local_storage_path}/tmp/duplicity-log" || [ ! -d "${backup_local_storage_path}/restores/s3/" ]
		then

			if [ "${1:-null}" = "test" ]
			then

				dna-echo -e "Testing restore from S3 failed."
				dna-echo -m "Is appears this instance of ${project_name} has on file an incorrect S3 encryption passphrase [check the above output for messages like: | ${r-}gpg: decryption failed: bad key${n-} |]."
				dna-echo -m "If this is the case, you've likely changed your backups encryption passphrase on this machine between your last backup and this one."
				dna-echo -m "This would cause S3 backups to be encrypted with two or more encryption keys at the same time, which would render them unusable in the future should you ever need them."
				dna-echo -m "Edit the file: | ${y-}${conf_backups_s3_dir}/backups_passphrase${n-} | and set once again your previous encryption passphrase, then re-run this script."
				dna-echo -m "If you have lost your previous encryption passphrase, delete all your S3 backups and re-run this script to make an entirely new backup set encrypted solely with the currently specified passphrase."
				dna-echo -e "Aborting S3 backup because of connection / integrity check failure."

				if [ ${interactive} = "y" ]
				then

					dna-ask_for_boolean -d "y" -q "Would you like to continue with a local-only backup anyway?"

			        if [ "${boolean_output}" = "y" ]
					then

						dna-echo -m "Ok, continuing with local-only backup."
						export s3_restore_test_failed="y"

					else

						dna-echo -m "Ok, aborting."
						dna-exit

					fi

				else

					dna-echo -m "Continuing with local-only backup anyway."
					export s3_restore_test_failed=y

				fi

			else

				dna-echo -e "Restore from S3 failed."
				dna-echo -m "Is appears this instance of ${project_name} has on file an incorrect S3 encryption passphrase [check the above output for messages like: | ${r-}gpg: decryption failed: bad key${n-} |]."
				dna-echo -m "Edit the file: | ${y-}${conf_backups_s3_dir}/backups_passphrase${n-} | and replace the currently specified passphrase with the old one from your previous machine, then re-run this script."
				dna-echo -m "If you have lost your previous encryption passphrase, you've also lost access to your backups."
				dna-exit

			fi

		else

			echo

			if [ "${1:-null}" = "test" ]
			then

				dna-echo -s "S3 Restore test succeded. Proceeding with S3 backup."

			else

				dna-echo -s "Restore succeded."

			fi

		fi

	fi

}

dna-launch_restore() {

	while getopts ":s" arguments
	do
		case $arguments in
			s)	restore_type="s3"
				skip_questions="y"
				restore_source="elsewhere"
				;;
			\?)	dna-echo -e "Invalid option | ${n-}-${OPTARG}${r-} | for function | ${n-}${FUNCNAME[0]}${r-} |."
                dna-exit
                ;;
		esac
	done
    OPTIND=1

	if [ ! ${skip_questions-null} = "y" ]
	then

	    choice="${b-}Is the backup you're trying to restore stored locally on this machine [i.e. you're trying to restore a previous state of this running instance of $project_name] or is it stored elsewhere [i.e. you're changing machine or your previous machine's data was wiped or lost]? ${x-}"
	    echo "$choice"
	    echo
	    options=("backup file stored locally" "backup file stored elsewhere" "exit")
	    select opt in "${options[@]}"
	    do
	    	echo
	    	case $opt in
	    		"backup file stored locally")
	    		export restore_source=here
	    		break
	    		;;
	    		"backup file stored elsewhere")
	    		export restore_source=elsewhere
	    		break
	    		;;
	    		"exit")
	    		echo "${b-}Exiting...${x-}"
	    		echo
	    		exit
	    		;;
	    		*)
	    		echo "${r-}${b-}Invalid option. Retry...${x-}"
	    		echo
	    		;;
	    	esac
	    done

	    if [ $restore_source = "here" ]
	    then

	    	dna-restore_from_here

	    else

	    	if [ "${backup_archival_location-null}" = "s3" ]
	    	then
	    		echo "${b-}You've previously set up an S3 file storage server connection on this machine.${x-}"
	    		echo
	    		choice="${b-}Do you want to restore from S3 or from a standalone $project_name backup file you have stored individually? ${x-}"
	    		echo "$choice"
	    		echo
	    		options=("S3" "standalone" "exit")
	    		select opt in "${options[@]}"
	    		do
	    			echo
	    			case $opt in
	    				"S3")
	    				export restore_type=s3
	    				break
	    				;;
	    				"standalone")
	    				export restore_type=standalone
	    				break
	    				;;
	    				"exit")
	    				echo "${b-}Exiting...${x-}"
	    				echo
	    				exit
	    				;;
	    				*)  echo "${r-}${b-}Invalid option. Retry...${x-}"
	    				echo
	    				;;
	    			esac
	    		done
	    	else
	    		export restore_type=standalone
	    	fi

			if [ $restore_type = "s3" ]
			then

				dna-restore_from_S3

			else

				dna-restore_from_standalone

				echo

			fi

		fi

	else

		dna-restore_from_S3

	fi

    if [ $restore_source = "here" ]
    then
    	export restore_file_name="$(echo "$sel_backup_file" | sed 's|./||g' | sed 's/-last-backup.*-restore//' | sed 's/.tar//g' | sed 's/.bz2//g')"
    	export restore_file_path="$backup_local_storage_path/restores/local/$restore_file_name"
    else
    	if [ $restore_type = "s3" ]
    	then
    		export restore_file_path="$backup_local_storage_path/restores/s3"
    	else
    		export restore_file_path="/root/$project_name-restore"
    	fi
    fi

	unset skip_questions

}
